# requirements.txt
annotated-types==0.7.0
anthropic==0.34.1
anyio==4.4.0
beautifulsoup4==4.12.3
bs4==0.0.2
certifi==2024.7.4
cffi==1.17.0
charset-normalizer==3.3.2
distro==1.9.0
dkimpy==1.1.8
dnspython==2.6.1
filelock==3.15.4
fsspec==2024.6.1
git-filter-repo==2.45.0
h11==0.14.0
httpcore==1.0.5
httpx==0.27.0
huggingface-hub==0.24.6
idna==3.7
jiter==0.5.0
packaging==24.1
patatt==0.6.3
pycparser==2.22
pydantic==2.8.2
pydantic_core==2.20.1
PyNaCl==1.5.0
PyYAML==6.0.2
requests==2.32.3
sniffio==1.3.1
soupsieve==2.6
tokenizers==0.20.0
tqdm==4.66.5
typing_extensions==4.12.2
urllib3==2.2.2


# chat_with_cache.py
import anthropic
import time
import os

client = anthropic.Anthropic()
MODEL_NAME = "claude-3-5-sonnet-20240620"

def read_codebase_content():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    file_path = os.path.join(script_dir, 'output.txt')
    
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            return file.read()
    except FileNotFoundError:
        print(f"Error: The file 'output.txt' was not found in {script_dir}")
        return None
    except Exception as e:
        print(f"An error occurred while reading the file: {str(e)}")
        return None

def send_message_to_claude(codebase_content, user_message):
    messages = [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "<codebase>" + codebase_content + "</codebase>",
                    "cache_control": {"type": "ephemeral"}
                },
                {
                    "type": "text",
                    "text": user_message
                }
            ]
        }
    ]

    start_time = time.time()
    response = client.messages.create(
        model=MODEL_NAME,
        max_tokens=1000,
        messages=messages,
        extra_headers={"anthropic-beta": "prompt-caching-2024-07-31"}
    )
    end_time = time.time()

    print(f"\nAPI call time: {end_time - start_time:.2f} seconds")
    print(f"Input tokens: {response.usage.input_tokens}")
    print(f"Output tokens: {response.usage.output_tokens}")
    print("\nClaude's response:")
    print(response.content[0].text)

    return response

def main():
    # Read the content of the codebase from output.txt
    codebase_content = read_codebase_content()

    if codebase_content is None:
        print("Exiting due to file read error.")
        exit(1)

    print(f"Read {len(codebase_content)} characters from the codebase.")

    # Start conversation
    print("Starting conversation with Claude. Type 'exit' to end the conversation.")
    while True:
        user_input = input("\nYour message: ")
        if user_input.lower() == 'exit':
            break
        
        send_message_to_claude(codebase_content, user_input)

if __name__ == "__main__":
    main()

# output.txt


# get_codebase.py
import os

def write_directory_contents_to_file(directory_path, output_file_path):
    # Files and directories to ignore
    ignore_list = {'__pycache__', '.venv', '.gitignore', 'package-lock.json', 'eslint.config.js', 'node_modules', '.git', 'DS_Store'}
    
    print(f"Starting to process directory: {directory_path}")
    print(f"Output will be written to: {output_file_path}")
    
    with open(output_file_path, 'w', encoding='utf-8') as output_file:
        for root, dirs, files in os.walk(directory_path):
            print(f"Current directory: {root}")
            
            # Remove ignored directories from dirs to prevent them from being searched
            dirs[:] = [d for d in dirs if d not in ignore_list]
            print(f"Subdirectories (after ignoring): {dirs}")
            
            print(f"Files: {files}")
            
            for file in files:
                if file not in ignore_list:
                    file_path = os.path.join(root, file)
                    relative_path = os.path.relpath(file_path, directory_path)
                    
                    print(f"Processing file: {relative_path}")
                    
                    # Write the file path as a comment
                    output_file.write(f"# {relative_path}\n")
                    
                    # Read and write the contents of the file
                    try:
                        with open(file_path, 'r', encoding='utf-8') as input_file:
                            content = input_file.read()
                            output_file.write(content)
                            print(f"Successfully wrote contents of {relative_path}")
                    except UnicodeDecodeError:
                        output_file.write("# Binary file, contents not shown\n")
                        print(f"Skipped binary file: {relative_path}")
                    except Exception as e:
                        print(f"Error processing {relative_path}: {str(e)}")
                    
                    # Add a newline for separation
                    output_file.write('\n\n')
                else:
                    print(f"Ignored file: {file}")

    print("Finished processing all files")

if __name__ == "__main__":
    # Prompt user for directory path, use current directory if no input
    directory_path = input("Enter the directory path to process (press Enter for current directory): ").strip()
    
    if not directory_path:
        directory_path = os.getcwd()
        print(f"Using current directory: {directory_path}")
    else:
        # Expand user home directory if needed
        directory_path = os.path.expanduser(directory_path)
    
    # Check if the directory exists
    if not os.path.isdir(directory_path):
        print(f"Error: The directory '{directory_path}' does not exist.")
        exit(1)
    
    # Prompt user for output file path, use default if no input
    output_file_path = input("Enter the output file path (press Enter for 'output.txt'): ").strip()
    
    if not output_file_path:
        output_file_path = 'output.txt'
        print(f"Using default output file: {output_file_path}")
    
    write_directory_contents_to_file(directory_path, output_file_path)
    
    print(f"Check if output file exists: {os.path.exists(output_file_path)}")
    if os.path.exists(output_file_path):
        print(f"Output file size: {os.path.getsize(output_file_path)} bytes")

